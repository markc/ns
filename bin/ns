#!/usr/bin/env bash
# Created: 20250723 - Updated: 20250723
# Copyright (C) 1995-2025 Mark Constable <mc@netserva.org> (MIT License)
# NetServa master command-line interface

# Strict mode disabled during development - will re-enable once basic functionality is stable
# TODO: Re-enable with: set -euo pipefail

# Script directory and library path
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
NSDIR="$(dirname "$SCRIPT_DIR")"

# Source NetServa master environment
source "$NSDIR/lib/nsrc.sh"

# Version information
NS_VERSION="0.1.0"
NS_BUILD_DATE="2025-07-21"

# Global variables
VERBOSE=0
DEBUG=0
DRY_RUN=0
CONFIG_FILE=""
LOG_LEVEL="INFO"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'
BOLD='\033[1m'

# Logging functions
log() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    case $level in
    ERROR) echo -e "${RED}[ERROR]${NC} $timestamp - $message" >&2 ;;
    WARN) echo -e "${YELLOW}[WARN]${NC}  $timestamp - $message" >&2 ;;
    INFO) [[ $LOG_LEVEL != "ERROR" ]] && echo -e "${BLUE}[INFO]${NC}  $timestamp - $message" ;;
    DEBUG) [[ $DEBUG -eq 1 ]] && echo -e "${PURPLE}[DEBUG]${NC} $timestamp - $message" ;;
    esac
}

error() {
    log "ERROR" "$1"
    exit "${2:-1}"
}
warn() { log "WARN" "$1"; }
info() { log "INFO" "$1"; }
debug() { log "DEBUG" "$1"; }

# Load additional libraries dynamically
load_lib() {
    local lib_name=$1
    local lib_file="$NSLIB/${lib_name}.sh"

    if [[ -f "$lib_file" ]]; then
        if source "$lib_file"; then
            debug "Loaded library: $lib_name"
            return 0
        else
            warn "Failed to source library: $lib_name"
            return 1
        fi
    else
        warn "Library not found: $lib_name"
        return 1
    fi
}

# Auto-generate list of available commands from main() function
get_available_commands() {
    # Extract commands from the case statement in main()
    grep -A 100 "# Route commands to appropriate handlers" "$0" |
        grep -E "^\s+[a-z-]+\)" |
        sed 's/^[[:space:]]*//' |
        sed 's/).*//' |
        grep -v "setup\|status\|start\|stop\|restart" |
        sort |
        tr '\n' ' '
}

# Load help from man files or fallback to inline help
show_help() {
    local command=${1:-""}
    local man_file="$NSMAN/${command:-ns}.md"

    # If man file exists, use glow to render it
    if [[ -f "$man_file" ]]; then
        if command -v glow >/dev/null 2>&1; then
            glow -w0 "$man_file"
        else
            cat "$man_file"
        fi
        return 0
    fi

    # Fallback for commands without man files
    case $command in
    "")
        # No command specified - show basic usage from man/ns.md or fallback
        if [[ -f "$NSMAN/ns.md" ]]; then
            if command -v glow >/dev/null 2>&1; then
                glow -w0 "$NSMAN/ns.md"
            else
                cat "$NSMAN/ns.md"
            fi
        else
            echo "NetServa v$NS_VERSION - Server Management System"
            echo ""
            echo "Usage: ns <command> [options] [arguments]"
            echo ""
            echo "Try: ns help        # Full help"
            echo "     ns status      # Check system status"
            echo "     ns mounts      # List mounted systems"
            echo "     ns ssh list    # List SSH configs"
        fi
        ;;
    *)
        # Generic help for commands without specific man files
        echo "NetServa v$NS_VERSION - $command command"
        echo ""
        echo "Usage: ns $command [options] [arguments]"
        echo ""
        echo "No detailed help available for this command yet."
        echo "Try: ns help          # Show available commands"
        echo "     ns $command --help   # Command-specific help (if supported)"
        ;;
    esac
}
# Version information
show_version() {
    cat <<EOF
NetServa v$NS_VERSION
Build Date: $NS_BUILD_DATE
Copyright (C) 1995-2025 Mark Constable <mc@netserva.org>
License: MIT License

Platform: $(uname -s) $(uname -m)
Bash: $BASH_VERSION
EOF
}

# Main command router
main() {
    local command=""
    local -a args=()

    # Handle case where no arguments are provided
    if [[ $# -eq 0 ]]; then
        show_help ""
        exit 0
    fi

    # Parse global options
    while [[ $# -gt 0 ]]; do
        case $1 in
        -v | --verbose)
            VERBOSE=1
            shift
            ;;
        -d | --debug)
            DEBUG=1
            VERBOSE=1
            shift
            ;;
        -q | --quiet)
            LOG_LEVEL="ERROR"
            shift
            ;;
        -c | --config)
            CONFIG_FILE="$2"
            shift 2
            ;;
        --dry-run)
            DRY_RUN=1
            shift
            ;;
        -h | --help)
            if [[ -n "${2:-}" ]] && [[ ! "$2" =~ ^- ]]; then
                show_help "$2"
            else
                show_help
            fi
            exit 0
            ;;
        -*)
            error "Unknown global option: $1"
            ;;
        *)
            command="$1"
            shift
            args=("$@")
            break
            ;;
        esac
    done

    # Load custom config if specified
    if [[ -n "$CONFIG_FILE" ]] && [[ -f "$CONFIG_FILE" ]]; then
        source "$CONFIG_FILE"
        debug "Loaded config: $CONFIG_FILE"
    fi

    # Handle special commands
    case $command in
    "" | help)
        show_help "${args[0]:-}"
        exit 0
        ;;
    version)
        show_version
        exit 0
        ;;
    esac

    # Route commands to appropriate handlers
    case $command in
    setup)
        load_lib "setup" || error "Setup module not available"
        setup_main "${args[@]}"
        ;;
    status)
        load_lib "services" || error "Services module not available"
        services_status "${args[@]}"
        ;;
    start | stop | restart)
        load_lib "services" || error "Services module not available"
        services_control "$command" "${args[@]}"
        ;;
    mount)
        load_lib "mount" || error "Mount module not available"
        mount_system "${args[@]}"
        ;;
    unmount)
        load_lib "mount" || error "Mount module not available"
        mount_unmount "${args[@]}"
        ;;
    remount)
        load_lib "mount" || error "Mount module not available"
        mount_remount "${args[@]}"
        ;;
    mounts | list-mounts)
        load_lib "mount" || error "Mount module not available"
        mount_list "${args[@]}"
        ;;
    deploy)
        load_lib "deploy" || error "Deploy module not available"
        deploy_main "${args[@]}"
        ;;
    backup)
        load_lib "backup" || error "Backup module not available"
        backup_main "${args[@]}"
        ;;
    restore)
        load_lib "backup" || error "Backup module not available"
        backup_restore "${args[@]}"
        ;;
    security)
        load_lib "security" || error "Security module not available"
        security_main "${args[@]}"
        ;;
    logs)
        load_lib "logging" || error "Logging module not available"
        logging_main "${args[@]}"
        ;;
    config)
        load_lib "config" || error "Config module not available"
        config_main "${args[@]}"
        ;;
    ssh)
        # Delegate to existing sshm script for now
        if [[ -x "$SCRIPT_DIR/sshm" ]]; then
            "$SCRIPT_DIR/sshm" "${args[@]}"
        else
            error "SSH module not available"
        fi
        ;;
    update)
        info "Update functionality not yet implemented"
        exit 252
        ;;
    doc|docs)
        # Interactive documentation browser
        if [[ -x "$SCRIPT_DIR/nsdoc" ]]; then
            "$SCRIPT_DIR/nsdoc" "${args[@]}"
        else
            error "Documentation browser not available"
        fi
        ;;
    *)
        error "Unknown command: $command. Use 'ns help' for available commands."
        ;;
    esac
}

# Error handling
trap 'error "Script interrupted" 130' INT
trap 'error "Script terminated" 143' TERM

# Initialize and run
debug "NetServa v$NS_VERSION starting"
debug "Root directory: $NSDIR"
debug "Library directory: $NSLIB"

main "$@"
